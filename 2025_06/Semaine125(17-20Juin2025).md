**17 Juin**
- [ ] ESLs
    - [x] Setup d√©but de semaine
        - [x] Reconnection base
            - D√©marrage de nMap
            - [x] target : 192.168.1.0/24
            - [x] ping scan dans le dropdown
            - [x] chercher Dongguan et aller √† l'ip renseign√©e par scan report
    - [ ] ESL-367 Cr√©er un script qui d√©tecte l'acc√®s √† internet ou non
        - [x] Cr√©er un nouveau fichier de script
            ```
            

            function Test-InternetAccess {
                try {
                    $response = Invoke-WebRequest -Uri "http://www.google.com" -TimeoutSec 10 -ErrorAction Stop
                    Write-Host "Access internet verifie."
                    return $true
                }
                catch {
                    Write-Host "Aucun acces a internet."
                    return $false
                }
            }

            $outputFile = "vitals_log.txt"
            $eslClientName = "Magasin de Test"      # Remplir ici localement le nom du magasin 
                                                    # o√π sera install√© le serveur esl


            while ($true) {
                $testResult = Test-InternetAccess
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"

                if (-not $testResult) {
                    $logMessage = "$timestamp : Aucun acces a internet."
                    $logMessage | Out-File -FilePath $outputFile -Append
                    Write-Host $logMessage
                } 
                }


                Start-Sleep -Seconds 300
            }
            Test-InternetAccess

            $testResult = Test-InternetAccess
            $outputFile = "vitals_log.txt"
            $testResult | Out-File -FilePath $outputFile -Force
            Write-Host "Erreur reportee dans le fichier $outputFile"
            ```
    - [ ] ESL-366 Cr√©er un script qui envoie un mail si les constantes n√©cessaires ne sont pas atteintes
        - [x] Cr√©ation d'un compte gmail :
        ```
        devcopamaco@gmail.com/@ESLs1234.-_#/ktdu alxo koum dmyi
        ```
        - [x] Acc√®s au google cloud
        - [x] Acc√®s dans le menu burger √† API&Services/Bibliothh√®que
        - [x] taper gmail api, cliquer et activer l'API
        - [x] Setup : 
             -   Go to "APIs & Services" > "Credentials".
             -   Create an OAuth 2.0 Client ID for a "Desktop App".
             -   Download the credentials JSON file.
    - [ ] S√©curisation du mdp smtp
    ```
    Le mot de passe SMTP est bien celui que tu saisis manuellement √† la cr√©ation du fichier XML, et non le mot de passe de ta session Windows.
    Mais ce mot de passe est ensuite chiffr√© avec ta session Windows, c‚Äôest-√†-dire :

    Seul ton compte utilisateur Windows (celui qui a cr√©√© le fichier .xml) peut le relire.

    Si quelqu‚Äôun d‚Äôautre r√©cup√®re ce fichier, il ne pourra pas s‚Äôen servir sur un autre PC ou compte utilisateur.

    üõ†Ô∏è √âtape d√©taill√©e pour renseigner ton mot de passe SMTP
    Tu vas utiliser Get-Credential, qui affiche une bo√Æte de dialogue o√π tu saisis √† la main :

    Nom d'utilisateur : devcopamaco@gmail.com

    Mot de passe : ton mot de passe d‚Äôapplication Gmail SMTP

    üîê Commande √† ex√©cuter (1 seule fois) pour g√©n√©rer le fichier s√©curis√© :
    powershell
    Copier
    Modifier
    $cred = Get-Credential
    $cred | Export-Clixml -Path "$env:USERPROFILE\CopAmacoSMTP.xml"
    Ce que fait cette commande :

    Get-Credential ouvre une fen√™tre comme celle-ci :



    Tu y entres :

    Nom d'utilisateur ‚Üí devcopamaco@gmail.com

    Mot de passe ‚Üí le mot de passe SMTP (fourni par Gmail, via Mots de passe d'application)

    Puis PowerShell enregistre tout cela de mani√®re chiffr√©e dans le fichier .xml.
    ```
    - [x] Fichiers finaux
        - [x] deployment.ps1 : 
        ```
        # Script qui d√©clenche le d√©ploiement automatique

        $sleepTime = 10 # Temps de boucle des checks
        $script1Path = ".\network_pingscan.ps1"
        $script2Path = ".\vitals_check.ps1"
        $script3Path = ".\containers_check.ps1"
        $credFilePath = "$env:USERPROFILE\CopAmacoSMTP.xml"

        Write-Host "Generation du fichier d'identifiants..."
        if (-Not (Test-Path $credFilePath)) {
            Write-Host "Generation du fichier d'identifiants..."
            $cred = Get-Credential
            $cred | Export-Clixml -Path $credFilePath
            Write-Host "Le fichier d'identifiants a ete cree a l'endroit : $credFilePath"
        } else {
            Write-Host "Fichier d'identifiants deja present : $credFilePath"
        }
        Write-Host "Le fichier d'identifiants a ete cree  a l'endroit : $env:USERPROFILE\CopAmacoSMTP.xml"

        Write-Host "Execution du ping des r√©seaux..."
        & powershell -File $script1Path

        Write-Host "Execution des checks de connexion internet..."
        Start-Process powershell -ArgumentList "-File `"$script2Path`" -SleepTime $sleepTime"

        Write-Host "Execution des checks de containers..."
        Start-Process powershell -ArgumentList "-File `"$script3Path`" -SleepTime $sleepTime"
        ```
        - [x] containers 
        ```
        param (
            [int]$sleepTime = 300 # Valeur par d√©faut au cas o√π aucun argument n'est pass√©
        )

        function Send-Email {
            param (
                [string]$to,
                [string]$subject,
                [string]$body,
                [string]$attachment
            )

            $smtpServer = "smtp.gmail.com"
            $smtpPort = 587
            $smtpUsername = "devcopamaco@gmail.com"
            try {
                $smtpCredential = Import-Clixml -Path "$env:USERPROFILE\CopAmacoSMTP.xml"
            } catch {
                Write-Host "Erreur lors de la r√©cup√©ration des identifiants SMTP : $_"
                return $false
            }

            $mailMessage = @{
                To = $to
                From = $smtpUsername
                Subject = $subject
                Body = $body
                Attachments = $attachment
                SmtpServer = $smtpServer
                Port = $smtpPort
                Credential = $smtpCredential
                UseSsl = $true
            }

            try {
                Send-MailMessage @mailMessage
                Write-Host "Email envoye avec succes."
                return $true
            }
            catch {
                Write-Host "Echec de l'envoi du mail: $_"
                return $false
            }
        }

        function Test-ContainerStatus {
        Write-Host "Execution des checks de containers..."
            try {
                $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                $containers = docker ps -a --format "{{.Names}}|{{.Status}}"
                $hasIssue = $false
                $logBuffer = @()

                foreach ($container in $containers) {
                    $parts = $container -split "\|"
                    $name = $parts[0]
                    $status = $parts[1]

                    if ($status -notmatch "^Up") {
                        $hasIssue = $true
                        $logMessage = "$timestamp : Le container '$name' est hors service. Statut: $status"
                        $logBuffer += $logMessage
                        Write-Host $logMessage
                    }
                }

                if ($hasIssue) {
                    return $logBuffer
                } else {
                    Write-Host "Tous les containers fonctionnent correctement."
                    return @()
                }
            }
            catch {
                Write-Host "Erreur lors de la v√©rification des containers."
                return @("Erreur lors de la v√©rification des containers.")
            }
        }

        $outputFile = "vitals_log.txt"
        $emailBufferFile = "email_buffer.txt"
        $eslClientName = "Magasin de Test"      # Remplir ici localement le nom du magasin 
                                                # o√π sera install√© le serveur esl

        $emailBuffer = @()

        while ($true) {
            $containerIssues = Test-ContainerStatus
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"

            if ($containerIssues.Count -gt 0) {
                $containerIssues | Out-File -FilePath $outputFile -Append
                $containerIssues | Out-File -FilePath $emailBufferFile -Append
                $emailBuffer += $containerIssues
                $issueDetected = $true
            }

            # Check if there are buffered emails to send
            if (Test-Path $emailBufferFile) {
                $emailBuffer = Get-Content $emailBufferFile
                if ($emailBuffer) {
                    # Send email with the buffered logs
                    $emailSubject = "Rapport d'erreur serveur ESL de $eslClientName"
                    $emailBody = "Des erreurs se sont produites sur le projet ESL du magasin $eslClientName. Ci-joint le d√©tail des erreurs."
                    $sendResult = Send-Email -to "g.chevalier@cop-amaco.com" -subject $emailSubject -body $emailBody -attachment $outputFile

                    if ($sendResult) {
                        Clear-Content $emailBufferFile
                    }
                }
            }


            if ($issueDetected ) {
                if (Test-Path $emailBufferFile) {
                    $emailBuffer = Get-Content $emailBufferFile
                    if ($emailBuffer) {
                        $emailSubject = "Rapport d'erreur serveur ESL de $eslClientName"
                        $emailBody = "Des erreurs se sont produites sur le projet ESL du magasin $eslClientName. Ci-joint le d√©tail des erreurs."
                        $sendResult = Send-Email -to "g.chevalier@cop-amaco.com" -subject $emailSubject -body $emailBody -attachment $outputFile

                        if ($sendResult) {
                            Clear-Content $emailBufferFile
                        }
                    }
                }
            }

            Start-Sleep -Seconds $sleepTime
        }
        Test-ContainerStatus

        $outputFile = "vitals_log.txt"
        Out-File -FilePath $outputFile -Force
        Write-Host "Erreur reportee dans le fichier $outputFile"
        ```
        - [x] vitals
        ```
        param (
            [int]$sleepTime = 300 # Valeur par d√©faut au cas o√π aucun argument n'est pass√©
        )

        function Send-Email {
            param (
                [string]$to,
                [string]$subject,
                [string]$body,
                [string]$attachment
            )

            $smtpServer = "smtp.gmail.com"
            $smtpPort = 587
            $smtpUsername = "devcopamaco@gmail.com"
            try {
                $smtpCredential = Import-Clixml -Path "$env:USERPROFILE\CopAmacoSMTP.xml"
            } catch {
                Write-Host "Erreur lors de la r√©cup√©ration des identifiants SMTP : $_"
                return $false
            }

            $mailMessage = @{
                To = $to
                From = $smtpUsername
                Subject = $subject
                Body = $body
                Attachments = $attachment
                SmtpServer = $smtpServer
                Port = $smtpPort
                Credential = $smtpCredential
                UseSsl = $true
            }

            try {
                Send-MailMessage @mailMessage
                Write-Host "Email envoye avec succes."
                return $true
            }
            catch {
                Write-Host "Echec de l'envoi du mail: $_"
                return $false
            }
        }

        function Test-InternetAccess {
        Write-Host "Execution des checks de connexion internet..."
            try {
                $response = Invoke-WebRequest -Uri "http://www.google.com" -TimeoutSec 10 -ErrorAction Stop
                Write-Host "Access internet verifie."
                return $true
            }
            catch {
                Write-Host "Aucun acces a internet."
                return $false
            }
        }


        $outputFile = "vitals_log.txt"
        $emailBufferFile = "email_buffer.txt"
        $eslClientName = "Magasin de Test"      # Remplir ici localement le nom du magasin 
                                                # o√π sera install√© le serveur esl

        $emailBuffer = @()

        while ($true) {
            $testResult = Test-InternetAccess
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"

            if (-not $testResult) {
                $logMessage = "$timestamp : Aucun acces a internet."
                $logMessage | Out-File -FilePath $outputFile -Append
                Write-Host $logMessage
                
                $emailBuffer += $logMessage
                $emailBuffer | Out-File -FilePath $emailBufferFile -Append
            } else {
                # Check if there are buffered emails to send
                if (Test-Path $emailBufferFile) {
                    $emailBuffer = Get-Content $emailBufferFile
                    if ($emailBuffer) {
                        # Send email with the buffered logs
                        $emailSubject = "Rapport d'erreur serveur ESL de $eslClientName"
                        $emailBody = "Des erreurs se sont produites sur le projet ESL du magasin $eslClientName. Ci-joint le d√©tail des erreurs."
                        $sendResult = Send-Email -to "g.chevalier@cop-amaco.com" -subject $emailSubject -body $emailBody -attachment $outputFile

                        if ($sendResult) {
                            Clear-Content $emailBufferFile
                        }
                    }
                }
            }


            Start-Sleep -Seconds $sleepTime
        }
        Test-InternetAccess

        $testResult = Test-InternetAccess
        $outputFile = "vitals_log.txt"
        $testResult | Out-File -FilePath $outputFile -Force
        Write-Host "Erreur reportee dans le fichier $outputFile"
        ```
        - [x] network
        ```
        # V√©rifier si nmap est install√©, sinon l'installer
        function Install-Nmap {
            if (-not (Get-Command nmap -ErrorAction SilentlyContinue)) {
                Write-Host "Installation de Nmap..."
                # T√©l√©charger et installer Nmap
                Invoke-WebRequest -Uri "https://nmap.org/dist/nmap-7.92-setup.exe" -OutFile "nmap-installer.exe"
                Start-Process -Wait -FilePath .\nmap-installer.exe -ArgumentList '/S'
                Remove-Item .\nmap-installer.exe
            } else {
                Write-Host "Nmap est deja installe."
            }
        }

        # Function to get the network prefix from ipconfig
        function Get-NetworkPrefix {
            $ipconfigOutput = ipconfig
            $ipv4Pattern = "(?:Adresse IPv4|IPv4 Address)[^:]+:\s*(\d{1,3}\.\d{1,3}\.\d{1,3})\.\d{1,3}"

            # Iterate through each line of the ipconfig output
            $ipconfigOutput | ForEach-Object {
                $line = $_
                if ($line -match $ipv4Pattern) {
                    $networkPrefix = $matches[1]
                    Write-Host "Adresse IP trouvee : $networkPrefix"
                }
            }

            if ($networkPrefix) {
                    Write-Host "Prefixe reseau : $networkPrefix"
                    return $networkPrefix
                } else {
                    throw "Impossible de d√©terminer le pr√©fixe r√©seau avec ipconfig."
                }
        }

        # Fonction pour scanner le r√©seau et d√©tecter les bases
        function Scan-Network {
            try {
                $networkPrefix = Get-NetworkPrefix
            }
            catch {
                Write-Host "Utilisation du prefixe reseau par defaut"
                $networkPrefix = "192.168.1"
            }
            $outputFile = "bases.txt"

            Write-Host "Debut du scan du reseau..."
            $scanResults = & nmap -sn "$networkPrefix.0/24"

            # Filtrer les r√©sultats pour obtenir les adresses IP des bases ESL
            $bases = $scanResults | Select-String -Pattern "Nmap scan report for (?:[a-zA-Z0-9.-]+\s*)?\(?(\d+\.\d+\.\d+\.\d+)\)?" | ForEach-Object {
                $ip = $_.Matches.Groups[1].Value
                $nextLine = $_.LineNumber + 1
                $macLine = $scanResults[$nextLine] | Select-String "MAC Address:.*Equitech Industrial\(DongGuan\)Co\."
                if ($macLine) {
                    Write-Output $ip
                }
            }

            # Sauvegarder les adresses IP dans un fichier
            $bases | Out-File -FilePath $outputFile -Force
            Write-Host "Les adresses IP des bases ont ete sauvegardees dans $outputFile"
        }

        # Ex√©cuter les fonctions
        Install-Nmap
        Scan-Network
        ```
    - [x] Cr√©ation du xml avec le password du smtp : 
        - $Credentials
        - rentrer l'adresse mail
        - rentrer le pw
- [ ] R√©aliser les tests nature de l'application
    - [ ] Pr√©parer le setup mat√©riel
        - [ ] R√©cup√©rer un routeur
    - [ ] R√©diger la charte de tests
    - [ ] Accompagner les testeurs