**02 Juin**
- [ ] ESLs
    - [x] Setup d√©but de semaine
        - [x] Reconnection base
            - D√©marrage de nMap
            - [x] target : 192.168.1.0/24
            - [x] ping scan dans le dropdown
            - [x] chercher Dongguan et aller √† l'ip renseign√©e par scan report
    - [ ] ESL-354  
    - [ ] ESL-361
    - [ ] ESL-305 : Supprimer la propri√©t√© eslId de l'entit√© storeArticle ?
        - [x] Question √† GPT : 
        ```
        un coll√®gue me dit que je devrais retirer la propri√©t√© eslId du storeArticle car c'est redondant. Je ne suis pas d'accord, car je l'utilise actuellement l'eslId dans un service pour r√©cup√©rer un storeArticle en fonction de son eslId. Je sais que je peux utiliser une jointure √† la place et supprimer le eslId, mais est-ce que √ßa vaut le coup, quelles sont les implications en terme de performances ?
        ```
        - [x] R√©ponse : 
        ```
        garder eslId explicitement ou utiliser les jointures ?
        ‚úîÔ∏è Avantages de garder eslId dans l'entit√© :
        Performances : tu peux faire une requ√™te simple :

        ts
        Copier
        Modifier
        const article = await storeArticleRepo.findOne({ where: { esl: { id: eslId } }, relations: ['esl'] });
        Ou m√™me (plus rapide, sans jointure) :

        ts
        Copier
        Modifier
        const article = await storeArticleRepo.findOne({ where: { eslId } });
        Simplicit√© de code : plus besoin de faire des jointures complexes si tu veux juste trouver un article par eslId.

        Lisibilit√© & maintenance : dans les services ou les filtres, c'est plus direct.

        ‚ùå Inconv√©nients potentiels :
        Redondance conceptuelle si tu commences √† exposer ou maintenir eslId et esl (risque de confusion sur la source de v√©rit√©).

        Mauvaise synchronisation possible si tu manipules eslId manuellement sans mettre √† jour esl.

        üöÄ En termes de performance
        Une jointure OneToOne est peu co√ªteuse dans PostgreSQL si l'indexation est bien faite (sur eslId).

        Mais si tu fais cette requ√™te souvent, sans avoir besoin de toutes les infos de Esl, le fait d‚Äôavoir eslId dans StoreArticle est plus rapide que de faire une jointure, c‚Äôest un acc√®s direct.

        üß† Conclusion : qui a raison ?
        Tu as raison de vouloir garder l‚Äôacc√®s √† eslId si tu l‚Äôutilises souvent comme crit√®re de recherche.

        Mais tu peux faire un compromis :

        Ne pas exposer eslId dans l'entit√© si ce n'est pas n√©cessaire pour les d√©veloppeurs.

        Cr√©er un index sur eslId dans la table store_article pour optimiser la requ√™te.

        Et garder la logique de relation esl intacte pour toutes les autres op√©rations.
        ```
    - [x] Remise en √©tat du setup esl
        - [x] Reconnection base
            - D√©marrage de nMap
            - [x] target : 192.168.1.0/24
            - [x] ping scan dans le dropdown
            - [x] chercher Dongguan et aller √† l'ip renseign√©e par scan report
    - [ ] ESL-340 Modifier les boutons de filtre de l'ESL-table pour afficher l'√©tat des filtres (actif ou non)
    - [x] Recherches sur la d√©tection automatique des bases : 
    ```
    Je suis d√©veloppeur sur un projet qui g√®re des √©tiquettes √©lectroniques de gondole, ou Electric Shelf Label, abr√©g√© ESL.
    Je poss√®de des ESLs qui interagissent avec une base qui a une macadresse sur le mod√®le : 40:D6:3C:01:A0:37, et qui est d√©tect√©e avec nmap comme : (Equitech Industrial(DongGuan)Co.)
    l'application en elle-m√™me est h√©berg√©e sur un serveur priv√© sous windows, sur lequel sont d√©marr√©s des containers docker pour Angular, NestJs, postgres, mongoDb, le mqtt_api & le mqtt_broker.

    Mon probl√®me est le suivant : A chaque d√©ploiement, je vais devoir installer plusieurs bases dont la  macadresse m'est inconnue. Je cherche donc un script qui puisse : 
    - installer nmap si ce n'est pas d√©j√† fait
    - effectuer un ping scan sur le r√©seau sur lequel sera l'application pour d√©tecter toutes les bases
    - lister l'adresse IP de chacune des bases
    - cr√©er un fichier nomm√© bases.txt et y r√©pertorier la liste d'adresses IP
    ```
    r√©ponse : 
    script powershell
    ```
    # V√©rifier si nmap est install√©, sinon l'installer
    function Install-Nmap {
        if (-not (Get-Command nmap -ErrorAction SilentlyContinue)) {
            Write-Host "Installation de Nmap..."
            # T√©l√©charger et installer Nmap
            Invoke-WebRequest -Uri "https://nmap.org/dist/nmap-7.92-setup.exe" -OutFile "nmap-installer.exe"
            Start-Process -Wait -FilePath .\nmap-installer.exe -ArgumentList '/S'
            Remove-Item .\nmap-installer.exe
        } else {
            Write-Host "Nmap est d√©j√† install√©."
        }
    }

    # Fonction pour scanner le r√©seau et d√©tecter les bases
    function Scan-Network {
        $networkPrefix = "192.168.1" # Remplacez par le pr√©fixe de votre r√©seau
        $outputFile = "bases.txt"

        Write-Host "D√©but du scan du r√©seau..."
        $scanResults = & nmap -sn "$networkPrefix.0/24"

        # Filtrer les r√©sultats pour obtenir les adresses IP des bases ESL
        $bases = $scanResults | Select-String -Pattern "Equitech Industrial\(DongGuan\)Co\." | ForEach-Object {
            $ip = ($_ -split '\s+')[4]
            Write-Output $ip
        }

        # Sauvegarder les adresses IP dans un fichier
        $bases | Out-File -FilePath $outputFile
        Write-Host "Les adresses IP des bases ont √©t√© sauvegard√©es dans $outputFile"
    }

    # Ex√©cuter les fonctions
    Install-Nmap
    Scan-Network
    ```
    commande pour le ping scan de nmap : 
    ```
    nmap -sn
    ```
    - [x] ESL-365 Cr√©er un script de d√©tection des bases sur le r√©seau local
        - [x] Cr√©ation d'un fichier network_pingscan.ps1
        ```
        # V√©rifier si nmap est install√©, sinon l'installer
        function Install-Nmap {
            if (-not (Get-Command nmap -ErrorAction SilentlyContinue)) {
                Write-Host "Installation de Nmap..."
                # T√©l√©charger et installer Nmap
                Invoke-WebRequest -Uri "https://nmap.org/dist/nmap-7.92-setup.exe" -OutFile "nmap-installer.exe"
                Start-Process -Wait -FilePath .\nmap-installer.exe -ArgumentList '/S'
                Remove-Item .\nmap-installer.exe
            } else {
                Write-Host "Nmap est d√©j√† install√©."
            }
        }

        # Fonction pour scanner le r√©seau et d√©tecter les bases
        function Scan-Network {
            $networkPrefix = "192.168.1" # Remplacez par le pr√©fixe de votre r√©seau
            $outputFile = "bases.txt"

            Write-Host "D√©but du scan du r√©seau..."
            $scanResults = & nmap -sn "$networkPrefix.0/24"

            # Filtrer les r√©sultats pour obtenir les adresses IP des bases ESL
            $bases = $scanResults | Select-String -Pattern "Nmap scan report for (?:[a-zA-Z0-9.-]+\s*)?\(?(\d+\.\d+\.\d+\.\d+)\)?" | ForEach-Object {
                $ip = $_.Matches.Groups[1].Value
                $nextLine = $_.LineNumber + 1
                $macLine = $scanResults[$nextLine] | Select-String "MAC Address:.*Equitech Industrial\(DongGuan\)Co\."
                if ($macLine) {
                    Write-Output $ip
                }
            }

            # Sauvegarder les adresses IP dans un fichier
            $bases | Out-File -FilePath $outputFile -Force
            Write-Host "Les adresses IP des bases ont √©t√© sauvegard√©es dans $outputFile"
        }

        # Ex√©cuter les fonctions
        Install-Nmap
        Scan-Network
        ```
    - [x] ESL-369 Cr√©er un script qui d√©termine le pr√©fixe r√©seau
    ```
    # Function to get the network prefix from ipconfig
    function Get-NetworkPrefix {
        $ipconfigOutput = ipconfig
        $ipv4Pattern = "(?:Adresse IPv4|IPv4 Address)[^:]+:\s*(\d{1,3}\.\d{1,3}\.\d{1,3})\.\d{1,3}"

        # Iterate through each line of the ipconfig output
        $ipconfigOutput | ForEach-Object {
            $line = $_
            if ($line -match $ipv4Pattern) {
                $networkPrefix = $matches[1]
                Write-Host "Adresse IP trouvee : $networkPrefix"
            }
        }

        if ($networkPrefix) {
                Write-Host "Prefixe reseau : $networkPrefix"
                return $networkPrefix
            } else {
                throw "Impossible de d√©terminer le pr√©fixe r√©seau avec ipconfig."
            }
    }
    ```