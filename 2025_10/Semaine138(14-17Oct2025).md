**14 Octobre**
- [x] Débrief BRIDGE : 
    - Pour réaliser efficacement la demande d'adapter bowtz, mieux vaut dupliquer le projet, et gérer le cas à part
        - Dupliquer le projet
        - Supprimer les mentions au mqtt
        - Créer une FastAPI qui réponde à la borne
        - Rediriger les requêtes du swagger vers la FastAPI
        - Précalculer en ram un maximum via getallesls
        - Créer un container docker
        - Ajouter le docker au compose
        - Développer les fonctionnalités
- [ ] ESL
    - [ ] Run down des étapes à faire : 
    ```
    1. Structure de la FastAPI
    Fichiers principaux
    Copierfastapi_bridge/
    ├── main.py              # Point d'entrée FastAPI
    ├── models.py            # Modèles Pydantic
    ├── services/            # Logique métier
    │   ├── esl_service.py   # Service pour les ESLs
    │   ├── bowtz_client.py  # Client HTTP pour BOWTZ
    │   └── utils.py         # Utilitaires (formatage des IDs, etc.)
    ├── Dockerfile
    └── requirements.txt

    2. Modèles Pydantic (models.py)
    Copierfrom pydantic import BaseModel
    from typing import Optional, List

    class ESL(BaseModel):
        tagId: str
        tagPower: Optional[float]
        tagTime: Optional[str]
        status: Optional[str]
        temperature: Optional[float]
        lqi: Optional[int]
        epdCode: Optional[str]
        pageNo: Optional[int]

    class Task(BaseModel):
        tid: str
        tagId: str
        taskStatus: str
        imageSrc: Optional[str]
        pageNo: Optional[int]
        startTime: Optional[str]
        endTime: Optional[str]

    class PicTaskRequest(BaseModel):
        tasks: List[dict]  # Ex: [{"tagId": "123", "imageSrc": "url", "pageNo": 1, "tid": "456"}]

    3. Client BOWTZ (services/bowtz_client.py)
    Copierimport httpx
    from fastapi import HTTPException
    from .models import ESL, Task

    class BowtzClient:
        def __init__(self, base_url: str, token: str):
            self.base_url = base_url
            self.token = token

        async def get_esl(self, tag_id: str) -> ESL:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/getTag",
                    headers={"appPoiAccessToken": self.token},
                    json={"current": 1, "size": 1, "tagId": self._format_tag_id(tag_id)}
                )
                if response.status_code != 200 or response.json().get("code") != 1:
                    raise HTTPException(status_code=404, detail="ESL not found")
                return ESL(**response.json()["data"]["records"][0])

        async def send_pic_task(self, tasks: List[dict]) -> List[Task]:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/sendPicTask",
                    headers={"appPoiAccessToken": self.token},
                    json={"tasks": tasks}
                )
                if response.status_code != 200 or response.json().get("code") != 1:
                    raise HTTPException(status_code=400, detail="Task failed")
                return [Task(**task) for task in response.json()["data"]]

        @staticmethod
        def _format_tag_id(tag_id: str) -> str:
            if len(tag_id) > 10:
                return tag_id[-10:]
            return tag_id.lstrip("0")

    4. Service ESL (services/esl_service.py)
    Copierfrom .bowtz_client import BowtzClient
    from .models import ESL, PicTaskRequest
    from typing import List

    class ESLService:
        def __init__(self, bowtz_client: BowtzClient):
            self.bowtz_client = bowtz_client

        async def get_esl(self, tag_id: str) -> ESL:
            return await self.bowtz_client.get_esl(tag_id)

        async def update_esl_image(self, tag_id: str, image_url: str, page_no: int = 1) -> List[Task]:
            tasks = [{"tagId": tag_id, "imageSrc": image_url, "pageNo": page_no, "tid": "unique_id"}]
            return await self.bowtz_client.send_pic_task(tasks)

        async def blink_esl(self, tag_id: str, color: str) -> Task:
            # BOWTZ utilise sendLedTask pour le clignotement
            tasks = [{"tagId": tag_id, "color": self._map_color(color), "count": 1, "freq": 100, "light": 20, "tid": "unique_id"}]
            return await self.bowtz_client.send_led_task(tasks)

        @staticmethod
        def _map_color(color: str) -> int:
            # Mapper les couleurs hexadécimales aux IDs BOWTZ
            color_map = {"#FF0000": 1, "#00FF00": 2, "#0000FF": 3}
            return color_map.get(color, 1)  # Rouge par défaut

    5. Endpoints FastAPI (main.py)
    Copierfrom fastapi import FastAPI, Depends, HTTPException
    from .services.esl_service import ESLService
    from .services.bowtz_client import BowtzClient
    from .models import ESL, PicTaskRequest

    app = FastAPI()

    # Initialisation des services
    bowtz_client = BowtzClient(base_url="http://139.224.201.5:8787", token="votre_appPoiAccessToken")
    esl_service = ESLService(bowtz_client)

    @app.get("/esl/{tag_id}", response_model=ESL)
    async def get_esl(tag_id: str):
        return await esl_service.get_esl(tag_id)

    @app.post("/esl/{tag_id}/image", response_model=List[Task])
    async def update_esl_image(tag_id: str, image_url: str, page_no: int = 1):
        return await esl_service.update_esl_image(tag_id, image_url, page_no)

    @app.post("/esl/{tag_id}/blink", response_model=Task)
    async def blink_esl(tag_id: str, color: str):
        return await esl_service.blink_esl(tag_id, color)

    6. Dockerfile
    CopierFROM python:3.11-slim
    WORKDIR /app
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    COPY . .
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

    7. Intégration avec NestJS
    Modifications nécessaires dans votre code NestJS

    Remplacer http://mqtt_api:5002 par l’URL de votre FastAPI (ex: http://fastapi_bridge:8000).
    Adapter les endpoints :

    esl_set_image → /esl/{tag_id}/image
    esl_blink → /esl/{tag_id}/blink


    Gérer les erreurs : Vérifiez les codes de retour de FastAPI et adaptez les HttpException en conséquence.
    ```
    - [ ] Setup du projet esl bowtz
        - [ ] gitisation
        - [ ] Installation de python
            - [ ] 

**17 Octobre**
- [ ] ESL
    - [ ] Setup du projet esl bowtz
        - [ ] gitisation
        - [ ] Installation de python
            - [ ] Création d'un venv (virtual environment)
            ```
            python -m venv venv
            .\venv\Scripts\activate
            ```
            - [x] Création d'un fichier environnement
            ```
            fastapi==0.109.0
            uvicorn==0.27.0
            httpx==0.26.0
            pytest==8.0.0
            ```
            - [x] Installation des dépendances
            ```pip install -r requirements.txt```
            - [x] Création de la structure du projet
            fastapi_bridge/
            ├── main.py
            ├── models.py
            ├── services/
            │   ├── __init__.py
            │   ├── bowtz_client.py
            │   └── esl_service.py
            ├── requirements.txt
            └── Dockerfile
            - [x] Fichier models.py (sert à décrire la structure des données qu’on va manipuler)
            ```
            from pydantic import BaseModel
            from typing import Optional, List

            class ESL(BaseModel):
                tagId: str
                tagPower: Optional[float]
                tagTime: Optional[str]
                status: Optional[str]
                temperature: Optional[float]
                lqi: Optional[int]
                epdCode: Optional[str]
                pageNo: Optional[int]

            class Task(BaseModel):
                tid: str
                tagId: str
                taskStatus: str
                imageSrc: Optional[str]
                pageNo: Optional[int]
                startTime: Optional[str]
                endTime: Optional[str]
            ```
            - [x] Création du fichier bowtz client.py
            ```
            import httpx
            from fastapi import HTTPException
            from ..models import ESL, Task

            class BowtzClient:
                def __init__(self, base_url: str, token: str):
                    self.base_url = base_url
                    self.token = token

                async def get_esl(self, tag_id: str) -> ESL:
                    async with httpx.AsyncClient() as client:
                        response = await client.post(
                            f"{self.base_url}/getTag",
                            headers={"appPoiAccessToken": self.token},
                            json={"current": 1, "size": 1, "tagId": self._format_tag_id(tag_id)}
                        )
                        if response.status_code != 200 or response.json().get("code") != 1:
                            raise HTTPException(status_code=404, detail="ESL not found")
                        return ESL(**response.json()["data"]["records"][0])

                async def send_pic_task(self, tasks: List[dict]) -> List[Task]:
                    async with httpx.AsyncClient() as client:
                        response = await client.post(
                            f"{self.base_url}/sendPicTask",
                            headers={"appPoiAccessToken": self.token},
                            json={"tasks": tasks}
                        )
                        if response.status_code != 200 or response.json().get("code") != 1:
                            raise HTTPException(status_code=400, detail="Task failed")
                        return [Task(**task) for task in response.json()["data"]]

                @staticmethod
                def _format_tag_id(tag_id: str) -> str:
                    if len(tag_id) > 10:
                        return tag_id[-10:]
                    return tag_id.lstrip("0")
            ```

Questions à poser concernant le projet LCD : en cas de changement (manuel ou non) d'IP de base/écran LCD ou de sous-réseau, comment être sûr qu'on va pas perdre la connexion entre LCD et base ?
Comment peut-on s'assurer de maîitriser la connexion LCD/base de bout en bout ?
Comment se passe l'assignation d'un LCD à une base ? A quelle base s'assigne un LCD s'il y a plusieurs bases ? Peut-on assigner manuellement un LCD à une base donnée s'il y en a plusieurs ?